package sort

/**
	冒泡排序的实现
		原理：
			1.从数组的第一个元素开始到最后一个元素，进行两两比较，将最小/最大的数像冒泡一样浮到数组的开头/结尾。
			2.进过第一轮比较，在数组的开头/结尾已经可以得到一个最小/最大的元素，因此下一步我们需要在除去开头/结尾元素的剩余元素中继续做两两比较
			3.依次类推，当我们作为比较轮次依据的数组下标移动到最后一位元素时（3个元素需要比较两轮,2个元素需要比较1轮，1个元素没有比较的必要），比较已经完全结束了，此时退出循环
		最好时间复杂度：O(n) [当数组本身就是有序时]
		最坏时间复杂度：O(n^2)
		平均时间复杂度: O(n^2)
		是否是稳定的排序：是（涉及两两比较的排序算法一定是稳定的排序）

	和选择排序算法做比较
		1.都是稳定的排序算法
		2.待排序元素较为有序的情况下循环次数将会大大减少
		3.每次循环都要对待排序区间的元素做两两比较，一旦不符合排序规则则会马上移动数组元素。
		  相对于选择排序此处开销过大，选择排序无论一轮排序中有多少个不符合排序规则的元素，
		  最终只需要移动一次数组元素。
 */
func BubbleSort(arr []int,compare Compare) {
	for i := 0; i < len(arr)-1; i++ {
		needSort := false
		for j := len(arr)-1; j > i; j--{
			if compare(arr[j-1],arr[j]) {
				arr[j],arr[j-1] = arr[j-1],arr[j]
				needSort = true
			}
		}
		if !needSort {
			return
		}
	}
}
